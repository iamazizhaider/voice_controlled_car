/******************************************************************************
	Course: Microprocessor System (Lab)
	
	Project name: Voice Controlled Car Using Tiva-C TM4C123GH6PM Launchpad 
	
	Description: The purpose of this project was to develop a robot which can operate on voice commands. To transmit voice commands from our 
	phone to the microcontroller (Tiva-C TM4C123GH6PM Launchpad), Bluetooth Module HC-05 was used which used UART communication protocol for 
	data transmission. UART Module 4 of the microcontroller was used for this purpose. To power the tyres of this robot car, 4 motors were 
	being controlled using L298N Dual H-Bridge Motor Driver. Their speed was controlled by PWM signal generated by the microcontroller. 2 Timer 
	modules were being used for this purpose --> TIMER2 & TIMER3. To ensure safety of the microcontroller from the back emf generated from motor
	incase it is disconnected suddenly, optocouplers were used which made sure that the microcontroller was isolated from the motors. Another 
	feature added to the robot was the distance measurement which made it stop when it got closer (less than 5cm) to any obstacle. For this purpose,
	we used Ultrasonic Sensor HC-SR04. The data was digitally collected so there was no need for analog to digital conversion. To sum up, this 
	robot can work on some specified commands which are stated as follows.
	1. Forward   --> Moves the car at 50% duty cycle in forward direction
	2. Backward	 --> Moves the car at 50% duty cycle in reverse direction
	3. Go Fast   --> Moves the car at 75% duty cycle in forward direction
	4. Go Faster --> Moves the car at 100% duty cycle in forward direction
	5. Slow Down --> Moves the car at 25% duty cycle in forward direction
	6. Left      --> Changes the direction to left and moves it in forward direction
	7. Right     --> Changes the direction to right and moves it in forward direction
	8. Stop      --> Stops the movement
	It is to be noted that the car doesn't work continously. For every command given to this robot, it will perform it and then stops after
	a maximum of 3 seconds (in case of changing direction). 
	
	Power Requirement: HC-05 & HC-SR04 are connected in paralled with a 9V battery. They can be connected with any source providing a 
	minimum of 5V. However the microcontroller & the motor driver L298N are powered with two 9V battery in series, providing 18V in total.
	For the optocouplers, a 9V battery is providing the VCC & GND to their circuit. 
	
	Team Members: 	Aziz Haider			2020-EE-172C
									Ali Hussain 		2020-EE-168C
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

//------------------------------------------------------------------------

# define SYSCTL_RCGC_GPIO_R 	*(( volatile unsigned long *) 0x400FE608 )

//GPIO Ports Base Addresses
#define PORT_A									0x40004000
#define PORT_B									0x40005000
#define PORT_C									0x40006000
#define PORT_D									0x40007000
#define PORT_E									0x40024000
#define PORT_F									0x40025000	

/* GPIO registers for Port B*/
#define 	GPIO_PORTB_AFSEL_R		(*((volatile unsigned long*)(PORT_B + 0x420)))	//Setting Alternate Functionality
#define 	GPIO_PORTB_PCTL_R			(*((volatile unsigned long*)(PORT_B + 0x52C)))	//To select what alternate functionality to choose
#define 	GPIO_PORTB_DEN_R   		(*((volatile unsigned long*)(PORT_B + 0x51C)))
#define 	GPIO_PORTB_DIR_R   		(*((volatile unsigned long*)(PORT_B + 0x400)))
#define 	GPIO_PORTB_LOCK_R 		(*((volatile unsigned long*)(PORT_B + 0x520)))
#define 	GPIO_PORTB_CR_R 			(*((volatile unsigned long*)(PORT_B + 0x524)))

/* GPIO registers for Port C*/
#define GPIO_PORTC_AFSEL_R 			(*((volatile unsigned long*)(PORT_C + 0x420)))
#define	GPIO_PORTC_PCTL_R 			(*((volatile unsigned long*)(PORT_C + 0x52C)))
#define GPIO_PORTC_DEN_R 				(*((volatile unsigned long*)(PORT_C + 0x51C)))
#define GPIO_PORTC_AMSEL_R 			(*((volatile unsigned long*)(PORT_C + 0x528)))

/* GPIO registers for Port E*/
#define	GPIO_PORTE_DEN_R 				(*((volatile unsigned long*)(PORT_E + 0x51C)))
#define	GPIO_PORTE_DATA_R				(*((volatile unsigned long*)(PORT_E + 0x3FC)))
#define	GPIO_PORTE_DIR_R				(*((volatile unsigned long*)(PORT_E + 0x400)))

/* GPIO registers for Port F*/
#define GPIO_PORTF_AFSEL_R		(*((volatile unsigned long*)(PORT_F + 0x420)))	//Setting Alternate Functionality
#define GPIO_PORTF_PCTL_R			(*((volatile unsigned long*)(PORT_F + 0x52C)))	//To select what alternate functionality to choose
#define GPIO_PORTF_DEN_R   		(*((volatile unsigned long*)(PORT_F + 0x51C)))
#define GPIO_PORTF_DATA_R   	(*((volatile unsigned long*)(PORT_F + 0x3FC)))
#define GPIO_PORTF_DIR_R   		(*((volatile unsigned long*)(PORT_F + 0x400)))
#define GPIO_PORTF_LOCK_R 		(*((volatile unsigned long*)(PORT_F + 0x520)))
#define GPIO_PORTF_CR_R 			(*((volatile unsigned long*)(PORT_F + 0x524)))

#define TRIG										0x10

//------------------------------------------------------------------------

//Clock for UART
# define SYSCTL_RCGC_UART_R 			(*((volatile unsigned long*)0x400FE618))

#define UART_0										0x4000C000
#define UART_1										0x4000D000
#define UART_2										0x4000E000
#define UART_3										0x4000F000
#define UART_4										0x40010000
#define UART_5										0x40011000
#define UART_6										0x40012000	
#define UART_7										0x40013000	
	
//Register definitions for UART module
#define UART_4_DATA_R 						(*((volatile unsigned long*)(UART_4 + 0x000)))
#define UART_4_RX_STATUS_R 				(*((volatile unsigned long*)(UART_4 + 0x004)))
#define UART_4_ERR_CLEAR_R 				(*((volatile unsigned long*)(UART_4 + 0x004)))
#define UART_4_FLAG_R 						(*((volatile unsigned long*)(UART_4 + 0x018)))
#define UART_4_BAUD_INT_R 				(*((volatile unsigned long*)(UART_4 + 0x024)))
#define UART_4_BAUD_FRAC_R 				(*((volatile unsigned long*)(UART_4 + 0x028)))
#define UART_4_LINE_CONTROL_R 		(*((volatile unsigned long*)(UART_4 + 0x02C)))
#define UART_4_CONTROL_R 					(*((volatile unsigned long*)(UART_4 + 0x030)))
#define UART_BUFFER_SIZE					256

#define UART_FR_TXFF            0x00000020  // UART Transmit FIFO Full
#define UART_FR_RXFE            0x00000010  // UART Receive FIFO Empty
#define UART_4_CTL_UARTEN       0x301  // UART Enable

//------------------------------------------------------------------------

//Peripheral clock enabling for timer
//page 338 of Data Sheet
#define		SYSCTL_RCGCTIMER_R			(*((volatile unsigned long*)0x400FE604))	

//page 726 of Data Sheet
#define 	CFG											0x000
#define 	MODE_A									0x004
#define 	MODE_B									0x008
#define 	CTL											0x00C
#define 	IL_A										0x028
#define 	IL_B										0x02C
#define 	MATCH_A									0x030
#define 	MATCH_B									0x034

#define 	TIMER0									0x40030000
#define 	TIMER1									0x40031000
#define 	TIMER2									0x40032000
#define 	TIMER3									0x40033000
#define 	TIMER4									0x40034000

//Registers for Timer 0
#define		TIMER_0_CFG_R						(*((volatile unsigned long*)(TIMER0 + CFG)))	
#define		TIMER_0_CTL_R						(*((volatile unsigned long*)(TIMER0 + CTL)))	
#define		TIMER_0A_MODE_R					(*((volatile unsigned long*)(TIMER0 + MODE_A)))
#define		TIMER_0A_ILR_R					(*((volatile unsigned long*)(TIMER0 + IL_A)))	
#define		TIMER_0_ICR_R						(*((volatile unsigned long*)(TIMER0 + 0x024)))
#define		TIMER_0_RIS_R						(*((volatile unsigned long*)(TIMER0 + 0x01C)))
#define		TIMER_0_TAR_R						(*((volatile unsigned long*)(TIMER0 + 0x048)))

#define		TIMER_1_CFG_R						(*((volatile unsigned long*)(TIMER1 + CFG)))	
#define		TIMER_1_CTL_R						(*((volatile unsigned long*)(TIMER1 + CTL)))	
#define		TIMER_1A_MODE_R					(*((volatile unsigned long*)(TIMER1 + MODE_A)))
#define		TIMER_1A_ILR_R					(*((volatile unsigned long*)(TIMER1 + IL_A)))	
#define		TIMER_1_ICR_R						(*((volatile unsigned long*)(TIMER1 + 0x024)))
#define		TIMER_1_RIS_R						(*((volatile unsigned long*)(TIMER1 + 0x01C)))

//Registers for Timer 2
#define		TIMER_2_CFG_R						(*((volatile unsigned long*)(TIMER2 + CFG)))	
#define		TIMER_2_CTL_R						(*((volatile unsigned long*)(TIMER2 + CTL)))	
#define		TIMER_2A_MODE_R					(*((volatile unsigned long*)(TIMER2 + MODE_A)))
#define		TIMER_2B_MODE_R					(*((volatile unsigned long*)(TIMER2 + MODE_B)))
#define		TIMER_2A_ILR_R					(*((volatile unsigned long*)(TIMER2 + IL_A)))	
#define		TIMER_2B_ILR_R					(*((volatile unsigned long*)(TIMER2 + IL_B)))	
#define		TIMER_2A_MATCH_R				(*((volatile unsigned long*)(TIMER2 + MATCH_A)))
#define		TIMER_2B_MATCH_R				(*((volatile unsigned long*)(TIMER2 + MATCH_B)))
#define		TIMER_2_ICR_R						(*((volatile unsigned long*)(TIMER2 + 0x024)))
#define		TIMER_2_IM_R						(*((volatile unsigned long*)(TIMER2 + 0x018)))
#define		TIMER_2_RIS_R						(*((volatile unsigned long*)(TIMER2 + 0x01C)))

//Registers for Timer 3
#define		TIMER_3_CFG_R						(*((volatile unsigned long*)(TIMER3 + CFG)))	
#define		TIMER_3_CTL_R						(*((volatile unsigned long*)(TIMER3 + CTL)))	
#define		TIMER_3A_MODE_R					(*((volatile unsigned long*)(TIMER3 + MODE_A)))
#define		TIMER_3B_MODE_R					(*((volatile unsigned long*)(TIMER3 + MODE_B)))
#define		TIMER_3A_ILR_R					(*((volatile unsigned long*)(TIMER3 + IL_A)))	
#define		TIMER_3B_ILR_R					(*((volatile unsigned long*)(TIMER3 + IL_B)))	
#define		TIMER_3A_MATCH_R				(*((volatile unsigned long*)(TIMER3 + MATCH_A)))
#define		TIMER_3B_MATCH_R				(*((volatile unsigned long*)(TIMER3 + MATCH_B)))
#define 	Reload									16000
#define 	TIMER_ICR_TATOCINT			0x01

//------------------------------------------------------------------------
void Ultrasonic_Sensor_Init ( void );
int Duration_Measure (void);
void Update_Distance(void);
void Delay_MicroSecond(int time);
void Bluetooth_Module_Init ( void );
char* UART_4_Read(void);
void Right(void);
void Left(void);
void Backward(void);
void Forward(void);
void Stop(void);
void go_fast(void);
void go_faster(void);
void slow_down(void);
void Timer_0_Init(void);
void Timer_2_Init(void);
void Timer_3_Init(void);
void TIMERS_Init (void);
void Delay ( volatile unsigned int delay );
void SystemInit (void);

unsigned int Distance, time;
char uart_buffer[UART_BUFFER_SIZE];

int main(void)
{
	char* command;
	
	Bluetooth_Module_Init();
	Ultrasonic_Sensor_Init();
	TIMERS_Init();

	while(1)
	{	
		Update_Distance();
		command = UART_4_Read(); 
		if(strcmp(command, "forward") == 0)						Forward();
		else if(strcmp(command, "backward") == 0)			Backward();
		else if(strcmp(command, "go fast") == 0)			go_fast();
		else if(strcmp(command, "go faster") == 0)		go_faster();
		else if(strcmp(command, "slow down") == 0)		slow_down();
		else if(strcmp(command, "left") == 0)					Left();
		else if(strcmp(command, "right") == 0)				Right();
		else if(strcmp(command, "stop") == 0)					Stop();
	}
}

void Ultrasonic_Sensor_Init ( void )
{
	SYSCTL_RCGC_GPIO_R |= 0x30;	//Port E & F
	
	//For PF0
	GPIO_PORTF_LOCK_R = 0x4C4F434B;	//To Unlock PF0
	GPIO_PORTF_CR_R = 0x01;
	GPIO_PORTF_DEN_R |= 0x01;
	GPIO_PORTF_AFSEL_R |= 0x01;
	GPIO_PORTF_PCTL_R |= 0x00000007;  
	GPIO_PORTF_DIR_R &= ~(0x01);
	
	//For PE4
	GPIO_PORTE_DEN_R |= 0x10;
	GPIO_PORTE_DIR_R |= 0x10;
}

int Duration_Measure (void)
{
  int lastEdge, thisEdge;

	//Connect TRIG at PE4
	//Connect ECHO at PF0
	
	GPIO_PORTE_DATA_R &= ~(TRIG);
	Delay_MicroSecond(10);
	//Keep TRIG high for 10us
	GPIO_PORTE_DATA_R |= TRIG;
	Delay_MicroSecond(10);
	GPIO_PORTE_DATA_R &= ~(TRIG); 
	while (1) {  
	TIMER_0_ICR_R = 0x04;            /* clear timer0A capture flag */
  while((TIMER_0_RIS_R & 0x04) == 0) ;    /* wait till captured */
	if(GPIO_PORTF_DATA_R & 0x01) /*check if rising edge occurs */
	{
		lastEdge = TIMER_0_TAR_R;			/* save the timestamp */			
		/* detect falling edge */
    TIMER_0_ICR_R = 0x04;            /* clear timer0A capture flag */
    while((TIMER_0_RIS_R & 0x04) == 0) ;    /* wait till captured */
    thisEdge = TIMER_0_TAR_R;     /* save the timestamp */
		return (thisEdge - lastEdge); /* return the time difference */
	}
	}
}

void Update_Distance(void)
{
	time = Duration_Measure();	
	Distance = (time * 10625)/10000000;
	if (Distance <= 5) Stop();
}

void Delay_MicroSecond(int time)
{
    int i;
    SYSCTL_RCGCTIMER_R |= 0x02;   /* enable clock to Timer Block 1 */
    TIMER_1_CTL_R = 0x00;         /* disable Timer before initialization */
    TIMER_1_CFG_R = 0x04;         /* 16-bit option */ 
    TIMER_1A_MODE_R = 0x02;       /* periodic mode and down-counter */
    TIMER_1A_ILR_R = 16 - 1;  		/* TimerA interval load value reg */
    TIMER_1_ICR_R = 0x01;         /* clear the TimerA timeout flag */
    TIMER_1_CTL_R |= 0x01;        /* enable Timer A after initialization */

    for(i = 0; i < time; i++)
    {
        while ((TIMER_1_RIS_R & 0x1) == 0) ;      /* wait for Timer1A timeout flag */
        TIMER_1_ICR_R = 0x1;      								/* clear the Timer1A timeout flag */
    }
}

void Bluetooth_Module_Init(void)
{
  SYSCTL_RCGC_UART_R |= 0x10;            		// activate UART4
  SYSCTL_RCGC_GPIO_R |= 0x04;			          // activate port C
	
  UART_4_CONTROL_R &= ~UART_4_CTL_UARTEN;   // disable UART
	//Baud Rate is set to 9600
  UART_4_BAUD_INT_R = 104;                  
  UART_4_BAUD_FRAC_R = 11;                  
																						// 8 bit word length (no parity bits, one stop bit, FIFOs)
  UART_4_LINE_CONTROL_R = 0x00000060;
  UART_4_CONTROL_R |= 0x301;    // enable UART
  
	GPIO_PORTC_AFSEL_R |= 0x30;           		// enable alt function on PC4 & PC5 
  GPIO_PORTC_DEN_R |= 0x30;             		// enable digital I/O on PC4 & PC5 
																					
  GPIO_PORTC_PCTL_R = (GPIO_PORTC_PCTL_R & 0xFF00FFFF) + 0x00110000;   // configure PC4 & PC5 as UART
  GPIO_PORTC_AMSEL_R &= ~(0x30);          	// disable analog functionality on PC4 & PC5 
}

char* UART_4_Read(void) {
    int i = 0;
    char c = 0;
    memset(uart_buffer, 0, UART_BUFFER_SIZE);
    while (1) {
			// Wait for data to be received
			while((UART_4_FLAG_R & UART_FR_RXFE) != 0){} 
      c = (char)(UART_4_DATA_R & 0xFF);    // Read the data
      if (c == '*') continue;
			if(c == '#' || i >= UART_BUFFER_SIZE-2) break;  
			uart_buffer[i++] = c;
    }
    return uart_buffer;
}

void Forward(void)
{	
	//Turn on the wheels for forward direction at 50% Duty Cycle
	Update_Distance();
	if (Distance > 5){
	TIMER_2A_MATCH_R = 15999;
	TIMER_2B_MATCH_R = 8000;
	TIMER_3A_MATCH_R = 15999;	
	TIMER_3B_MATCH_R = 8000;
	Delay(600000);
	Stop();			
	}
	else Stop();
}

void Backward(void)
{
	//Turn on the wheels for backward direction at 50% Duty Cycle
	TIMER_2A_MATCH_R = 8000;
	TIMER_2B_MATCH_R = 15999;
	TIMER_3A_MATCH_R = 8000;	
	TIMER_3B_MATCH_R = 15999;
	Delay(600000);
	Stop();			
}

void slow_down(void)
{	
	//Check if the car is moving forward or reverse direction  
	Update_Distance();
	if (Distance > 5){
		//Rotate them at 50% Duty Cycle 
		TIMER_2B_MATCH_R = 12000;
		TIMER_3B_MATCH_R = 12000;
		Delay(600000);
		Stop();			
	}
	else Stop();
}

void go_fast(void)
{	
	//Check if the car is moving forward or reverse direction  
	Update_Distance();
	if (Distance > 5){
		//Rotate them at 75% Duty Cycle 
		TIMER_2B_MATCH_R = 4000;
		TIMER_3B_MATCH_R = 4000;
		Delay(600000);
		Stop();			
	} 
	else Stop();
}

void go_faster(void)
{	
	//Check if the car is moving forward or reverse direction  
	Update_Distance();
	if (Distance > 5){
		//Rotate them at 75% Duty Cycle 
		TIMER_2B_MATCH_R = 0;
		TIMER_3B_MATCH_R = 0;
		Delay(600000);
		Stop();			
	} 
	else Stop();
}

void Left (void)
{
	Update_Distance();
	if (Distance > 5) {
		TIMER_2B_MATCH_R = 15999;
		TIMER_3B_MATCH_R = 12000;
		Delay(1200000);
		Forward();
		Delay(135500);
		Stop();
	}
	else Stop();
}


void Right (void)
{
	Update_Distance();
	if (Distance > 5) {
		TIMER_2B_MATCH_R = 12000;
		TIMER_3B_MATCH_R = 15999;
		Delay(1355000);
		Forward();
		Delay(140000);
		Stop();
	}
	else Stop();
}

void Stop(void)
{
	TIMER_2A_MATCH_R = 15999;
	TIMER_2B_MATCH_R = 15999;
	TIMER_3A_MATCH_R = 15999;	
	TIMER_3B_MATCH_R = 15999;
}

/* Timer 0 Configuration --> PF0*/
void Timer_0_Init(void)
{
	/* Enable clock for Timer */
	SYSCTL_RCGCTIMER_R |= 0x01;

	/* Disable Timer before setup */
	TIMER_0_CTL_R &= 0x00;	//Page 737 of Data Sheet
	
	/* Configure 16-bit timer mode */
	//Put 4 in GPTM_R for the 32 bit timer to be used as 16 bit timer
	TIMER_0_CFG_R |= 0x00000004; //Page 727 of Data Sheet									
	
	TIMER_0A_MODE_R |= 0x17;					

	/* Enable Timer after setup */
	TIMER_0_CTL_R |= 0x0C;
	
	TIMER_0_CTL_R |= 0x01;
}

/* Timer 2 Configuration */
void Timer_2_Init(void)
{
	/* Enable clock for Timer */
	SYSCTL_RCGCTIMER_R |= 0x04;

	/* Disable Timer before setup */
	TIMER_2_CTL_R &= 0x00000000;	//Page 737 of Data Sheet
	
	/* Configure 16-bit timer mode */
	//Put 4 in GPTM_R for the 32 bit timer to be used as 16 bit timer
	TIMER_2_CFG_R |= 0x00000004; //Page 727 of Data Sheet									
	
	/* Configure periodic mode */
	//Setting it in periodic as well as in PWM mode & as a down counter
	TIMER_2A_MODE_R |= 0x0000000A;					

	TIMER_2B_MODE_R |= 0x0000000A;					

	/* Set initial load value or reload value*/
	//We want PWM frequency of 1kHz which means (1/1000)s of interval
	//Reload = (Interval)*(clk_frequency)
	//Reload = (1/1000)*(16MHz)
	TIMER_2A_ILR_R = Reload;																		

	TIMER_2B_ILR_R = Reload;																		

	TIMER_2A_MATCH_R = Reload - 1;
	
	TIMER_2B_MATCH_R = Reload - 1;
	
	/* Enable Timer after setup */
	TIMER_2_CTL_R |= 0x00000101;	//Page 737 of Data Sheet
}

/* Timer 3 Configuration */
void Timer_3_Init(void)
{
	/* Enable clock for Timer */
	SYSCTL_RCGCTIMER_R |= 0x08;

	/* Disable Timer before setup */
	TIMER_3_CTL_R &= 0x00000000;	//Page 737 of Data Sheet
	
	/* Configure 16-bit timer mode */
	//Put 4 in GPTM_R for the 32 bit timer to be used as 16 bit timer
	TIMER_3_CFG_R |= 0x00000004; //Page 727 of Data Sheet									
	
	/* Configure periodic mode */
	//Setting it in periodic as well as in PWM mode & as a down counter
	TIMER_3A_MODE_R |= 0x0000000A;					

	TIMER_3B_MODE_R |= 0x0000000A;					

	/* Set initial load value or reload value*/
	//We want PWM frequency of 1kHz which means (1/1000)s of interval
	//Reload = (Interval)*(clk_frequency)
	//Reload = (1/1000)*(16MHz)
	TIMER_3A_ILR_R = Reload;																		

	TIMER_3B_ILR_R = Reload;																		
	
	TIMER_3A_MATCH_R = Reload - 1;

	TIMER_3B_MATCH_R = Reload - 1;
	
	/* Enable Timer after setup */
	TIMER_3_CTL_R |= 0x00000101;	//Page 737 of Data Sheet
}

void TIMERS_Init (void)
{
	volatile unsigned long ulLoop ;
	
	SYSCTL_RCGC_GPIO_R |= 0x02;

	/* Dummy read to stable the clock */
	ulLoop = SYSCTL_RCGC_GPIO_R ;

	//PORTS FOR TIMER IN PWM MODE
	GPIO_PORTB_DEN_R |= 0x0F;
	GPIO_PORTB_AFSEL_R |= 0x0F;
	GPIO_PORTB_PCTL_R |= 0x7777;  
	GPIO_PORTB_DIR_R |= 0x0F;	//Direction set as output 
	
	Timer_0_Init();
	Timer_2_Init();
	Timer_3_Init();
}

/* This function generates the delay . */
void Delay ( volatile unsigned int delay )
{
long int i;
for (i = 0; i < (delay*3) ; i ++){Update_Distance();}
}

void SystemInit (void)
{
	  /* --------------------------FPU settings ----------------------------------*/
	#if (__FPU_USED == 1)
		SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
                  (3UL << 11*2)  );               /* set CP11 Full Access */
	#endif
}
